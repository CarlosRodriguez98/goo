{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/CarlosRodriguez98/goo/blob/master/Proyect_Supervisado\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "run_control": {
          "marked": true
        },
        "id": "_QITsNvzKhxk"
      },
      "source": [
        "# Machine Learning Foundation\n",
        "\n",
        "## Proyecto Andres Rodriguez\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "XQeeUR76Khxn"
      },
      "source": [
        "## Introduccion\n",
        "\n",
        "Usaremos el conjunto de datos de calidad del vino para estos ejercicios. Este conjunto de datos contiene varias propiedades químicas del vino, como acidez, azúcar, pH y alcohol. También contiene una métrica de calidad (3-9, siendo la más alta mejor) y un color (rojo o blanco). El nombre del archivo es `Wine_Quality_Data.csv`."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:57.164238Z",
          "start_time": "2017-04-09T20:04:57.158472-04:00"
        },
        "id": "7ff6yj_FKhxo"
      },
      "outputs": [],
      "source": [
        "def warn(*args, **kwargs):\n",
        "    pass\n",
        "import warnings\n",
        "warnings.warn = warn\n",
        "\n",
        "import pandas as pd, numpy as np, matplotlib.pyplot as plt, seaborn as sns"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "AzSDI2bdKhxq"
      },
      "source": [
        "## Question 1\n",
        "\n",
        "\n",
        "* Importar los datos y examinar las características.\n",
        "* Los usaremos todos para predecir el \"color\" (blanco o rojo), pero la función de colores deberá codificarse en números enteros.\n"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "### BEGIN SOLUTION\n",
        "\n",
        "data = pd.read_excel(\"BolsaValores.xlsx\")\n",
        "print(data)"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "ytt69qjECeyR",
        "outputId": "a8d23a91-a6f7-4a89-ec34-b2d14ba01073"
      },
      "execution_count": 10,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "           FECHA                                   EMISOR  \\\n",
            "0     2021-01-04       HOMEFOREST EL REFUGIO FORESTAL S A   \n",
            "1     2021-01-04       CERRO VERDE FORESTAL S A BIGFOREST   \n",
            "2     2021-01-04                CORPORACION FAVORITA C.A.   \n",
            "3     2021-01-04                CORPORACION FAVORITA C.A.   \n",
            "4     2021-01-04                                 EL TECAL   \n",
            "...          ...                                      ...   \n",
            "14539 2022-12-09                     MUTUALISTA PICHINCHA   \n",
            "14540 2022-12-09                     MUTUALISTA PICHINCHA   \n",
            "14541 2022-12-09                     MUTUALISTA PICHINCHA   \n",
            "14542 2022-12-09  BANCO DE LA PRODUCCION S.A . PRODUBANCO   \n",
            "14543 2022-12-09  BANCO DE LA PRODUCCION S.A . PRODUBANCO   \n",
            "\n",
            "                            VALOR  VALOR NOMINAL  PRECIO  NUMERO ACCIONES  \\\n",
            "0                        ACCIONES              1   25.68              550   \n",
            "1                        ACCIONES              1   31.91             1100   \n",
            "2                        ACCIONES              1    2.41             1999   \n",
            "3                        ACCIONES              1    2.40             4081   \n",
            "4                        ACCIONES              1   35.00              550   \n",
            "...                           ...            ...     ...              ...   \n",
            "14539  CERTIFICADOS DE APORTACION            100  100.00                2   \n",
            "14540  CERTIFICADOS DE APORTACION            100  100.00                2   \n",
            "14541  CERTIFICADOS DE APORTACION            100  100.00                2   \n",
            "14542                    ACCIONES              1    0.72            16686   \n",
            "14543                    ACCIONES              1    0.72             8742   \n",
            "\n",
            "       VALOR EFECTIVO PROCEDENCIA  \n",
            "0            14124.00           G  \n",
            "1            35101.00           G  \n",
            "2             4817.59           Q  \n",
            "3             9794.40           G  \n",
            "4            19250.00           G  \n",
            "...               ...         ...  \n",
            "14539          200.00           Q  \n",
            "14540          200.00           Q  \n",
            "14541          200.00           Q  \n",
            "14542        12013.92           Q  \n",
            "14543         6294.24           Q  \n",
            "\n",
            "[14544 rows x 8 columns]\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 11,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:57.769148Z",
          "start_time": "2017-04-09T20:04:57.734768-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 354
        },
        "id": "F-_tdoFTKhxq",
        "outputId": "597e7d71-ad22-4d14-8477-bda96baf4ec0"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "       FECHA                              EMISOR     VALOR  VALOR NOMINAL  \\\n",
              "0 2021-01-04  HOMEFOREST EL REFUGIO FORESTAL S A  ACCIONES              1   \n",
              "1 2021-01-04  CERRO VERDE FORESTAL S A BIGFOREST  ACCIONES              1   \n",
              "2 2021-01-04           CORPORACION FAVORITA C.A.  ACCIONES              1   \n",
              "3 2021-01-04           CORPORACION FAVORITA C.A.  ACCIONES              1   \n",
              "4 2021-01-04                            EL TECAL  ACCIONES              1   \n",
              "\n",
              "   PRECIO  NUMERO ACCIONES  VALOR EFECTIVO PROCEDENCIA  \n",
              "0   25.68              550        14124.00           G  \n",
              "1   31.91             1100        35101.00           G  \n",
              "2    2.41             1999         4817.59           Q  \n",
              "3    2.40             4081         9794.40           G  \n",
              "4   35.00              550        19250.00           G  "
            ],
            "text/html": [
              "\n",
              "  <div id=\"df-241e3496-c098-490e-a14a-515c0ac158f2\">\n",
              "    <div class=\"colab-df-container\">\n",
              "      <div>\n",
              "<style scoped>\n",
              "    .dataframe tbody tr th:only-of-type {\n",
              "        vertical-align: middle;\n",
              "    }\n",
              "\n",
              "    .dataframe tbody tr th {\n",
              "        vertical-align: top;\n",
              "    }\n",
              "\n",
              "    .dataframe thead th {\n",
              "        text-align: right;\n",
              "    }\n",
              "</style>\n",
              "<table border=\"1\" class=\"dataframe\">\n",
              "  <thead>\n",
              "    <tr style=\"text-align: right;\">\n",
              "      <th></th>\n",
              "      <th>FECHA</th>\n",
              "      <th>EMISOR</th>\n",
              "      <th>VALOR</th>\n",
              "      <th>VALOR NOMINAL</th>\n",
              "      <th>PRECIO</th>\n",
              "      <th>NUMERO ACCIONES</th>\n",
              "      <th>VALOR EFECTIVO</th>\n",
              "      <th>PROCEDENCIA</th>\n",
              "    </tr>\n",
              "  </thead>\n",
              "  <tbody>\n",
              "    <tr>\n",
              "      <th>0</th>\n",
              "      <td>2021-01-04</td>\n",
              "      <td>HOMEFOREST EL REFUGIO FORESTAL S A</td>\n",
              "      <td>ACCIONES</td>\n",
              "      <td>1</td>\n",
              "      <td>25.68</td>\n",
              "      <td>550</td>\n",
              "      <td>14124.00</td>\n",
              "      <td>G</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>1</th>\n",
              "      <td>2021-01-04</td>\n",
              "      <td>CERRO VERDE FORESTAL S A BIGFOREST</td>\n",
              "      <td>ACCIONES</td>\n",
              "      <td>1</td>\n",
              "      <td>31.91</td>\n",
              "      <td>1100</td>\n",
              "      <td>35101.00</td>\n",
              "      <td>G</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>2</th>\n",
              "      <td>2021-01-04</td>\n",
              "      <td>CORPORACION FAVORITA C.A.</td>\n",
              "      <td>ACCIONES</td>\n",
              "      <td>1</td>\n",
              "      <td>2.41</td>\n",
              "      <td>1999</td>\n",
              "      <td>4817.59</td>\n",
              "      <td>Q</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>3</th>\n",
              "      <td>2021-01-04</td>\n",
              "      <td>CORPORACION FAVORITA C.A.</td>\n",
              "      <td>ACCIONES</td>\n",
              "      <td>1</td>\n",
              "      <td>2.40</td>\n",
              "      <td>4081</td>\n",
              "      <td>9794.40</td>\n",
              "      <td>G</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>4</th>\n",
              "      <td>2021-01-04</td>\n",
              "      <td>EL TECAL</td>\n",
              "      <td>ACCIONES</td>\n",
              "      <td>1</td>\n",
              "      <td>35.00</td>\n",
              "      <td>550</td>\n",
              "      <td>19250.00</td>\n",
              "      <td>G</td>\n",
              "    </tr>\n",
              "  </tbody>\n",
              "</table>\n",
              "</div>\n",
              "      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-241e3496-c098-490e-a14a-515c0ac158f2')\"\n",
              "              title=\"Convert this dataframe to an interactive table.\"\n",
              "              style=\"display:none;\">\n",
              "        \n",
              "  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n",
              "       width=\"24px\">\n",
              "    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n",
              "    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n",
              "  </svg>\n",
              "      </button>\n",
              "      \n",
              "  <style>\n",
              "    .colab-df-container {\n",
              "      display:flex;\n",
              "      flex-wrap:wrap;\n",
              "      gap: 12px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert {\n",
              "      background-color: #E8F0FE;\n",
              "      border: none;\n",
              "      border-radius: 50%;\n",
              "      cursor: pointer;\n",
              "      display: none;\n",
              "      fill: #1967D2;\n",
              "      height: 32px;\n",
              "      padding: 0 0 0 0;\n",
              "      width: 32px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert:hover {\n",
              "      background-color: #E2EBFA;\n",
              "      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "      fill: #174EA6;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert {\n",
              "      background-color: #3B4455;\n",
              "      fill: #D2E3FC;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert:hover {\n",
              "      background-color: #434B5C;\n",
              "      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n",
              "      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n",
              "      fill: #FFFFFF;\n",
              "    }\n",
              "  </style>\n",
              "\n",
              "      <script>\n",
              "        const buttonEl =\n",
              "          document.querySelector('#df-241e3496-c098-490e-a14a-515c0ac158f2 button.colab-df-convert');\n",
              "        buttonEl.style.display =\n",
              "          google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "\n",
              "        async function convertToInteractive(key) {\n",
              "          const element = document.querySelector('#df-241e3496-c098-490e-a14a-515c0ac158f2');\n",
              "          const dataTable =\n",
              "            await google.colab.kernel.invokeFunction('convertToInteractive',\n",
              "                                                     [key], {});\n",
              "          if (!dataTable) return;\n",
              "\n",
              "          const docLinkHtml = 'Like what you see? Visit the ' +\n",
              "            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n",
              "            + ' to learn more about interactive tables.';\n",
              "          element.innerHTML = '';\n",
              "          dataTable['output_type'] = 'display_data';\n",
              "          await google.colab.output.renderOutput(dataTable, element);\n",
              "          const docLink = document.createElement('div');\n",
              "          docLink.innerHTML = docLinkHtml;\n",
              "          element.appendChild(docLink);\n",
              "        }\n",
              "      </script>\n",
              "    </div>\n",
              "  </div>\n",
              "  "
            ]
          },
          "metadata": {},
          "execution_count": 11
        }
      ],
      "source": [
        "data.head()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 12,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:57.797727Z",
          "start_time": "2017-04-09T20:04:57.771736-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "dM31KuDdKhxr",
        "outputId": "3b544235-396a-4ea7-8b89-4c043134258f"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "FECHA              datetime64[ns]\n",
              "EMISOR                     object\n",
              "VALOR                      object\n",
              "VALOR NOMINAL               int64\n",
              "PRECIO                    float64\n",
              "NUMERO ACCIONES             int64\n",
              "VALOR EFECTIVO            float64\n",
              "PROCEDENCIA                object\n",
              "dtype: object"
            ]
          },
          "metadata": {},
          "execution_count": 12
        }
      ],
      "source": [
        "data.dtypes"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "CClnoMnDKhxr"
      },
      "source": [
        "\n",
        "\n",
        "```\n",
        "# Esto tiene formato de código\n",
        "```\n",
        "\n",
        "\n",
        "Convierta la característica de color en un número entero. Esta es una forma rápida de hacerlo usando Pandas."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 17,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:57.821162Z",
          "start_time": "2017-04-09T20:04:57.801357-04:00"
        },
        "id": "FtAa5gLtKhxr"
      },
      "outputs": [],
      "source": [
        "data['PROCEDENCIA'] = data.PROCEDENCIA.replace('G',0).replace('Q',1).astype(np.int)\n",
        "### END SOLUTION"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3nQJpOu0Khxr"
      },
      "source": [
        "## Question 2\n",
        "\n",
        "* Use `StratifiedShuffleSplit` para dividir los datos en conjuntos de prueba y de entrenamiento estratificados por calidad del vino. Si es posible, conserve los índices de la división para la pregunta 5 a continuación.\n",
        "* Compruebe la composición porcentual de cada nivel de calidad para los conjuntos de datos del tren y de la prueba.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 18,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:57.827405Z",
          "start_time": "2017-04-09T20:04:57.823619-04:00"
        },
        "id": "_FkVGBG3Khxs"
      },
      "outputs": [],
      "source": [
        "### BEGIN SOLUTION\n",
        "# All data columns except for color\n",
        "feature_cols = [x for x in data.columns if x not in 'PROCEDENCIA']"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 19,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:58.162153Z",
          "start_time": "2017-04-09T20:04:57.830037-04:00"
        },
        "id": "AeEHDs-3Khxs"
      },
      "outputs": [],
      "source": [
        "from sklearn.model_selection import StratifiedShuffleSplit\n",
        "\n",
        "# Split the data into two parts with 1000 points in the test data\n",
        "# This creates a generator\n",
        "strat_shuff_split = StratifiedShuffleSplit(n_splits=1, test_size=1000, random_state=42)\n",
        "\n",
        "# Get the index values from the generator\n",
        "train_idx, test_idx = next(strat_shuff_split.split(data[feature_cols], data['PROCEDENCIA']))\n",
        "\n",
        "# Create the data sets\n",
        "X_train = data.loc[train_idx, feature_cols]\n",
        "y_train = data.loc[train_idx, 'PROCEDENCIA']\n",
        "\n",
        "X_test = data.loc[test_idx, feature_cols]\n",
        "y_test = data.loc[test_idx, 'PROCEDENCIA']"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "HkopIhRkKhxs"
      },
      "source": [
        "\n",
        "Ahora verifique la composición porcentual de cada nivel de calidad en los conjuntos de datos de entrenamiento y prueba. El conjunto de datos es principalmente vino blanco, como se puede ver a continuación."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 20,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:58.177504Z",
          "start_time": "2017-04-09T20:04:58.164339-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "Hr4_9xgkKhxs",
        "outputId": "811f7e1c-d8d2-47ef-bdb3-349a06796b9c"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "0    0.303455\n",
              "1    0.696545\n",
              "Name: PROCEDENCIA, dtype: float64"
            ]
          },
          "metadata": {},
          "execution_count": 20
        }
      ],
      "source": [
        "y_train.value_counts(normalize=True).sort_index()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 21,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:58.188717Z",
          "start_time": "2017-04-09T20:04:58.180142-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "AAWnhmsTKhxt",
        "outputId": "099a4268-4057-4e49-bd3b-d38bb8d0d5b0"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "0    0.303\n",
              "1    0.697\n",
              "Name: PROCEDENCIA, dtype: float64"
            ]
          },
          "metadata": {},
          "execution_count": 21
        }
      ],
      "source": [
        "y_test.value_counts(normalize=True).sort_index()\n",
        "### END SOLUTION"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "vH3XXuw-Khxt"
      },
      "source": [
        "## Question 3\n",
        "\n",
        "*   Fit a decision tree classifier with no set limits on maximum depth, features, or leaves.\n",
        "*   Determine how many nodes are present and what the depth of this (very large) tree is.\n",
        "*   Using this tree, measure the prediction error in the train and test data sets. What do you think is going on here based on the differences in prediction error?\n",
        "\n",
        "* Ajuste un clasificador de árboles de decisión sin límites establecidos en la profundidad máxima, las características o las hojas.\n",
        "* Determine cuántos nodos están presentes y cuál es la profundidad de este árbol (muy grande).\n",
        "* Con este árbol, mida el error de predicción en los conjuntos de datos de prueba y tren. ¿Qué crees que está pasando aquí en base a las diferencias en el error de predicción?"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 24,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:58.276188Z",
          "start_time": "2017-04-09T20:04:58.191882-04:00"
        },
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 346
        },
        "id": "sfv9Rc2rKhxt",
        "outputId": "79d42000-2331-4af9-f045-b1849110f477"
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "TypeError",
          "evalue": "ignored",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
            "\u001b[0;32m<ipython-input-24-077a0fe5668f>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0mdt\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mDecisionTreeClassifier\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrandom_state\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m42\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 5\u001b[0;31m \u001b[0mdt\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_train\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_train\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
            "\u001b[0;32m/usr/local/lib/python3.8/dist-packages/sklearn/tree/_classes.py\u001b[0m in \u001b[0;36mfit\u001b[0;34m(self, X, y, sample_weight, check_input, X_idx_sorted)\u001b[0m\n\u001b[1;32m    935\u001b[0m         \"\"\"\n\u001b[1;32m    936\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 937\u001b[0;31m         super().fit(\n\u001b[0m\u001b[1;32m    938\u001b[0m             \u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    939\u001b[0m             \u001b[0my\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.8/dist-packages/sklearn/tree/_classes.py\u001b[0m in \u001b[0;36mfit\u001b[0;34m(self, X, y, sample_weight, check_input, X_idx_sorted)\u001b[0m\n\u001b[1;32m    163\u001b[0m             \u001b[0mcheck_X_params\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mDTYPE\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maccept_sparse\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"csc\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    164\u001b[0m             \u001b[0mcheck_y_params\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mensure_2d\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 165\u001b[0;31m             X, y = self._validate_data(\n\u001b[0m\u001b[1;32m    166\u001b[0m                 \u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mvalidate_separately\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcheck_X_params\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcheck_y_params\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    167\u001b[0m             )\n",
            "\u001b[0;32m/usr/local/lib/python3.8/dist-packages/sklearn/base.py\u001b[0m in \u001b[0;36m_validate_data\u001b[0;34m(self, X, y, reset, validate_separately, **check_params)\u001b[0m\n\u001b[1;32m    576\u001b[0m                 \u001b[0;31m# :(\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    577\u001b[0m                 \u001b[0mcheck_X_params\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcheck_y_params\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mvalidate_separately\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 578\u001b[0;31m                 \u001b[0mX\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcheck_array\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mcheck_X_params\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    579\u001b[0m                 \u001b[0my\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcheck_array\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0my\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mcheck_y_params\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    580\u001b[0m             \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.8/dist-packages/sklearn/utils/validation.py\u001b[0m in \u001b[0;36mcheck_array\u001b[0;34m(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator)\u001b[0m\n\u001b[1;32m    744\u001b[0m                     \u001b[0marray\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0marray\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mastype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdtype\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcasting\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"unsafe\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcopy\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    745\u001b[0m                 \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 746\u001b[0;31m                     \u001b[0marray\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0masarray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0morder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0morder\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdtype\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    747\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mComplexWarning\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mcomplex_warning\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    748\u001b[0m                 raise ValueError(\n",
            "\u001b[0;32m/usr/local/lib/python3.8/dist-packages/pandas/core/generic.py\u001b[0m in \u001b[0;36m__array__\u001b[0;34m(self, dtype)\u001b[0m\n\u001b[1;32m   1991\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1992\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m__array__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mNpDtype\u001b[0m \u001b[0;34m|\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndarray\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1993\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0masarray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_values\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdtype\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1994\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1995\u001b[0m     def __array_wrap__(\n",
            "\u001b[0;31mTypeError\u001b[0m: float() argument must be a string or a number, not 'Timestamp'"
          ]
        }
      ],
      "source": [
        "### BEGIN SOLUTION\n",
        "from sklearn.tree import DecisionTreeClassifier\n",
        "\n",
        "dt = DecisionTreeClassifier(random_state=42)\n",
        "dt = dt.fit(X_train, y_train)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "DJuD8O1gKhxt"
      },
      "source": [
        "The number of nodes and the maximum actual depth.\n",
        "\n",
        "El número de nodos y la profundidad máxima real."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 25,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:58.288400Z",
          "start_time": "2017-04-09T20:04:58.278395-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 165
        },
        "id": "3l5PZnqIKhxu",
        "outputId": "46d22c23-92c9-48cf-8b9a-abfd156c4f1a"
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "AttributeError",
          "evalue": "ignored",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
            "\u001b[0;32m<ipython-input-25-294241738823>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mdt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtree_\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnode_count\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtree_\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmax_depth\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
            "\u001b[0;31mAttributeError\u001b[0m: 'DecisionTreeClassifier' object has no attribute 'tree_'"
          ]
        }
      ],
      "source": [
        "dt.tree_.node_count, dt.tree_.max_depth"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "GDBCNGmwKhxu"
      },
      "source": [
        "A function to return error metrics.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:58.300905Z",
          "start_time": "2017-04-09T20:04:58.291784-04:00"
        },
        "id": "WebEgi3uKhxu"
      },
      "outputs": [],
      "source": [
        "from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\n",
        "\n",
        "def measure_error(y_true, y_pred, label):\n",
        "    return pd.Series({'accuracy':accuracy_score(y_true, y_pred),\n",
        "                      'precision': precision_score(y_true, y_pred),\n",
        "                      'recall': recall_score(y_true, y_pred),\n",
        "                      'f1': f1_score(y_true, y_pred)},\n",
        "                      name=label)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "IwqsN3ToKhxu"
      },
      "source": [
        "The decision tree predicts a little better on the training data than the test data, which is consistent with (mild)  overfitting. Also notice the perfect recall score for the training data. In many instances, this prediction difference is even greater than that seen here.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:04:58.347704Z",
          "start_time": "2017-04-09T20:04:58.304211-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "id": "7X6V3bKGKhxu"
      },
      "outputs": [],
      "source": [
        "# The error on the training and test data sets\n",
        "y_train_pred = dt.predict(X_train)\n",
        "y_test_pred = dt.predict(X_test)\n",
        "\n",
        "train_test_full_error = pd.concat([measure_error(y_train, y_train_pred, 'train'),\n",
        "                              measure_error(y_test, y_test_pred, 'test')],\n",
        "                              axis=1)\n",
        "\n",
        "train_test_full_error\n",
        "### END SOLUTION"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "V-NyQvngKhxv"
      },
      "source": [
        "## Question 4\n",
        "\n",
        "*   Using grid search with cross validation, find a decision tree that performs well on the test data set. Use a different variable name for this decision tree model than in question 3 so that both can be used in question 6.\n",
        "*   Determine the number of nodes and the depth of this tree.\n",
        "*   Measure the errors on the training and test sets as before and compare them to those from the tree in question 3.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:00.723922Z",
          "start_time": "2017-04-09T20:04:58.350434-04:00"
        },
        "id": "YJha0SDwKhxv"
      },
      "outputs": [],
      "source": [
        "### BEGIN SOLUTION\n",
        "from sklearn.model_selection import GridSearchCV\n",
        "\n",
        "param_grid = {'max_depth':range(1, dt.tree_.max_depth+1, 2),\n",
        "              'max_features': range(1, len(dt.feature_importances_)+1)}\n",
        "\n",
        "GR = GridSearchCV(DecisionTreeClassifier(random_state=42),\n",
        "                  param_grid=param_grid,\n",
        "                  scoring='accuracy',\n",
        "                  n_jobs=-1)\n",
        "\n",
        "GR = GR.fit(X_train, y_train)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "asnXQJ_qKhxv"
      },
      "source": [
        "The number of nodes and the maximum depth of the tree.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:00.732520Z",
          "start_time": "2017-04-09T20:05:00.726551-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "id": "Vd15QrnTKhxv"
      },
      "outputs": [],
      "source": [
        "GR.best_estimator_.tree_.node_count, GR.best_estimator_.tree_.max_depth"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "NfHYSA7sKhxv"
      },
      "source": [
        "These test errors are a little better than the previous ones. So it would seem the previous example overfit the data, but only slightly so.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:00.761770Z",
          "start_time": "2017-04-09T20:05:00.736164-04:00"
        },
        "id": "SS1EBvwqKhxw"
      },
      "outputs": [],
      "source": [
        "y_train_pred_gr = GR.predict(X_train)\n",
        "y_test_pred_gr = GR.predict(X_test)\n",
        "\n",
        "train_test_gr_error = pd.concat([measure_error(y_train, y_train_pred_gr, 'train'),\n",
        "                                 measure_error(y_test, y_test_pred_gr, 'test')],\n",
        "                                axis=1)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:00.778206Z",
          "start_time": "2017-04-09T20:05:00.763889-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "id": "aMSHrCVMKhxw"
      },
      "outputs": [],
      "source": [
        "train_test_gr_error\n",
        "### END SOLUTION"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "HF0AN77NKhxw"
      },
      "source": [
        "## Question 5\n",
        "\n",
        "*   Re-split the data into `X` and `y` parts, this time with `residual_sugar` being the predicted (`y`) data. *Note:* if the indices were preserved from the `StratifiedShuffleSplit` output in question 2, they can be used again to split the data.\n",
        "*   Using grid search with cross validation, find a decision tree **regression** model that performs well on the test data set.\n",
        "*   Measure the errors on the training and test sets using mean squared error.\n",
        "*   Make a plot of actual *vs* predicted residual sugar.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:00.801822Z",
          "start_time": "2017-04-09T20:05:00.781094-04:00"
        },
        "id": "zw7M0w3zKhxw"
      },
      "outputs": [],
      "source": [
        "### BEGIN SOLUTION\n",
        "feature_cols = [x for x in data.columns if x != 'residual_sugar']\n",
        "\n",
        "# Create the data sets\n",
        "X_train = data.loc[train_idx, feature_cols]\n",
        "y_train = data.loc[train_idx, 'residual_sugar']\n",
        "\n",
        "X_test = data.loc[test_idx, feature_cols]\n",
        "y_test = data.loc[test_idx, 'residual_sugar']"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:05.108706Z",
          "start_time": "2017-04-09T20:05:00.805520-04:00"
        },
        "id": "18Li4w8xKhxw"
      },
      "outputs": [],
      "source": [
        "from sklearn.tree import DecisionTreeRegressor\n",
        "\n",
        "dr = DecisionTreeRegressor().fit(X_train, y_train)\n",
        "\n",
        "param_grid = {'max_depth':range(1, dr.tree_.max_depth+1, 2),\n",
        "              'max_features': range(1, len(dr.feature_importances_)+1)}\n",
        "\n",
        "GR_sugar = GridSearchCV(DecisionTreeRegressor(random_state=42),\n",
        "                     param_grid=param_grid,\n",
        "                     scoring='neg_mean_squared_error',\n",
        "                      n_jobs=-1)\n",
        "\n",
        "GR_sugar = GR_sugar.fit(X_train, y_train)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "vjAd6XPuKhxx"
      },
      "source": [
        "The number of nodes and the maximum depth of the tree. This tree has lots of nodes, which is not so surprising given the continuous data.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:05.119777Z",
          "start_time": "2017-04-09T20:05:05.111176-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "id": "RsBxnoA3Khxx"
      },
      "outputs": [],
      "source": [
        "GR_sugar.best_estimator_.tree_.node_count, GR_sugar.best_estimator_.tree_.max_depth"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "poN0CrnwKhxx"
      },
      "source": [
        "The error on train and test data sets. Since this is continuous, we will use mean squared error.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:05.148178Z",
          "start_time": "2017-04-09T20:05:05.122534-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "id": "gq8XHjihKhxx"
      },
      "outputs": [],
      "source": [
        "from sklearn.metrics import mean_squared_error\n",
        "\n",
        "y_train_pred_gr_sugar = GR_sugar.predict(X_train)\n",
        "y_test_pred_gr_sugar  = GR_sugar.predict(X_test)\n",
        "\n",
        "train_test_gr_sugar_error = pd.Series({'train': mean_squared_error(y_train, y_train_pred_gr_sugar),\n",
        "                                         'test':  mean_squared_error(y_test, y_test_pred_gr_sugar)},\n",
        "                                          name='MSE').to_frame().T\n",
        "\n",
        "train_test_gr_sugar_error"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "K4Kt2MgdKhxx"
      },
      "source": [
        "A plot of actual vs predicted residual sugar.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:05.578043Z",
          "start_time": "2017-04-09T20:05:05.355944-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "id": "R9OeU0iMKhxx"
      },
      "outputs": [],
      "source": [
        "sns.set_context('notebook')\n",
        "sns.set_style('white')\n",
        "fig = plt.figure(figsize=(6,6))\n",
        "ax = plt.axes()\n",
        "\n",
        "ph_test_predict = pd.DataFrame({'test':y_test.values,\n",
        "                                'predict': y_test_pred_gr_sugar}).set_index('test').sort_index()\n",
        "\n",
        "ph_test_predict.plot(marker='o', ls='', ax=ax)\n",
        "ax.set(xlabel='Test', ylabel='Predict', xlim=(0,35), ylim=(0,35));\n",
        "### END SOLUTION"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "k0MFn4a7Khxy"
      },
      "source": [
        "## Question 6\n",
        "\n",
        "This question requires an additional command line program (GraphViz) and Python library (PyDotPlus). GraphViz can be installed with a package manager on Linux and Mac. For PyDotPlus, either `pip` or `conda` (`conda install -c conda-forge pydotplus`) can be used to install the library.\n",
        "\n",
        "Once these programs are installed:\n",
        "\n",
        "*   Create a visualization of the decision tree from question 3, where wine color was predicted and the number of features and/or splits are not limited.\n",
        "*   Create a visualization of the decision tree from question 4, where wine color was predicted but a grid search was used to find the optimal depth and number of features.\n",
        "\n",
        "The decision tree from question 5 will likely have too many nodes to visualize.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:05.588035Z",
          "start_time": "2017-04-09T20:05:05.579730-04:00"
        },
        "id": "yRC85wPoKhxy"
      },
      "outputs": [],
      "source": [
        "from io import StringIO\n",
        "from IPython.display import Image\n",
        "from sklearn.tree import export_graphviz\n",
        "import pydotplus"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "2ds8nZa2Khxy"
      },
      "source": [
        "The tree from question 3.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:08.253110Z",
          "start_time": "2017-04-09T20:05:05.590645-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "id": "CitYQPrTKhxy"
      },
      "outputs": [],
      "source": [
        "### BEGIN SOLUTION\n",
        "# Create an output destination for the file\n",
        "dot_data = StringIO()\n",
        "\n",
        "export_graphviz(dt, out_file=dot_data, filled=True)\n",
        "graph = pydotplus.graph_from_dot_data(dot_data.getvalue())\n",
        "\n",
        "# View the tree image\n",
        "filename = 'wine_tree.png'\n",
        "graph.write_png(filename)\n",
        "Image(filename=filename) "
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "7E1zJRufKhxz"
      },
      "source": [
        "The tree fit with cross validation from question 4. This tree is much shallower than the previous one.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "ExecuteTime": {
          "end_time": "2017-04-10T00:05:10.669095Z",
          "start_time": "2017-04-09T20:05:08.257642-04:00"
        },
        "jupyter": {
          "outputs_hidden": false
        },
        "id": "Byw_iCtSKhxz"
      },
      "outputs": [],
      "source": [
        "# Create an output destination for the file\n",
        "dot_data = StringIO()\n",
        "\n",
        "export_graphviz(GR.best_estimator_, out_file=dot_data, filled=True)\n",
        "graph = pydotplus.graph_from_dot_data(dot_data.getvalue())\n",
        "\n",
        "# View the tree image\n",
        "filename = 'wine_tree_prune.png'\n",
        "graph.write_png(filename)\n",
        "Image(filename=filename) \n",
        "### END SOLUTION"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "6jlnr9TaKhxz"
      },
      "source": [
        "***\n",
        "\n",
        "### Machine Learning Foundation (C) 2020 IBM Corporation\n"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3.10.2 64-bit",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.10.2"
    },
    "vscode": {
      "interpreter": {
        "hash": "369f2c481f4da34e4445cda3fffd2e751bd1c4d706f27375911949ba6bb62e1c"
      }
    },
    "colab": {
      "provenance": [],
      "include_colab_link": true
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}